  #pragma once

#ifdef _WIN32
#pragma warning(push)
#pragma warning(disable: 4244 4267)
#endif

#include "common.pb.h"
#include "editor_settings.pb.h"
#include "effect_settings.pb.h"
#include "effect_settings_plexus.pb.h"
#include "editor_styles.pb.h"
#include <bristol/flags.hpp>

#ifdef _WIN32
#pragma warning(pop)
#endif

namespace editor
{
  {% for class in all_classes %}
  struct {{ class }};
  {% endfor %}

  {% for class in classes %}
  {{ class.name }} FromProtocol(const {{ class.proto_type }}& p);
  void ToProtocol(const {{ class.name}}& v, {{ class.proto_type}}* p);
  {% endfor %}
  {% for fwd in forward_decls %}
  {{ fwd }}

  {% endfor %}
  
  template<typename T, typename U>
  vector<T> FromProtocolRepeated(const google::protobuf::RepeatedPtrField<U>& v)
  {
    vector<T> res;
    for (const auto& x : v)
    {
      res.push_back(FromProtocol(x));
    }
    return res;
  }
  
  {% for class in classes %}
  struct {{ class.name }}
  {
    {% for enum in class.enums %}
    enum class {{ enum.name }}
    {
    {% for value in enum.vals %}
      {{ value.name }} = {{ value.number }},
    {% endfor %}
    };

    {% endfor %}
    {% for member in class.members %}
    {% if member.default_value %}
    {{ member.type }} {{ member.name }} = {{ member.default_value }};
    {% else %}
    {{ member.type }} {{ member.name }};
    {% endif %}
    {% endfor %}
  };

  {% endfor %}  

  inline Color FromProtocol(const common::protocol::Color4& col)
  {
    return Color(col.r(), col.g(), col.b(), col.a());
  }

  inline void ToProtocol(const Color& v, common::protocol::Color4* p)
  {
    p->set_r(v.r);
    p->set_g(v.g);
    p->set_b(v.b);
    p->set_a(v.a);
  }

  inline Vector3f FromProtocol(const common::protocol::Vector3& v)
  {
    return Vector3f(v.x(), v.y(), v.z());
  }

  inline void ToProtocol(const Vector3f& v, common::protocol::Vector3* p)
  {
    p->set_x(v.x);
    p->set_y(v.y);
    p->set_z(v.z);
  }

  inline Vector2f FromProtocol(const common::protocol::Vector2& v)
  {
    return Vector2f(v.x(), v.y());
  }

  inline void ToProtocol(const Vector2f& v, common::protocol::Vector2* p)
  {
    p->set_x(v.x);
    p->set_y(v.y);
  }

  {% for class in classes %}
  inline {{ class.name }} FromProtocol(const {{ class.proto_type }}& p)
  {
    {{ class.name }} res;
    {% for member in class.members %}
    {% if member.is_enum %}
    res.{{ member.name }} = ({{ member.type}})p.{{ member.proto_name }}();
    {% elif member.is_native %}
    if (p.has_{{ member.proto_name}}())
    {
      res.{{ member.name }} = p.{{ member.proto_name }}();
    }
    {% elif member.is_bytes %}
    res.{{ member.name }}.resize(p.{{ member.proto_name }}().size());
    memcpy(res.{{ member.name }}.data(), p.{{ member.proto_name }}().data(), p.{{ member.proto_name }}().size());
    {% else %}
    {% if member.is_repeated %}
    res.{{ member.name }} = FromProtocolRepeated<{{ member.base_type }}>(p.{{ member.proto_name }}());
    {% else %}
    if (p.has_{{ member.proto_name}}())
    {
      res.{{ member.name }} = FromProtocol(p.{{ member.proto_name }}());
    }
    {% endif %}
    {% endif %}
    {% endfor %}
    return res;
  }

  inline void ToProtocol(const {{ class.name }}& v, {{ class.proto_type }}* p)
  {
    {% for member in class.members %}
    {% if member.is_enum %}
    {% elif member.is_native %}
    p->set_{{ member.proto_name }}(v.{{ member.name }});
    {% elif member.is_bytes %}
    {% else %}
    {% if member.is_repeated %}
    for (const auto& x : v.{{ member.name }})
      ToProtocol(x, p->add_{{ member.proto_name}}());
    {% else %}
    ToProtocol(v.{{ member.name }}, p->mutable_{{ member.proto_name }}());
    {% endif %}
    {% endif %}
    {% endfor %}
  }

  {% endfor %}	
}

